// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: upsert_items.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const upsertItems = `-- name: UpsertItems :many

INSERT INTO smart_table_customer.items (
    uuid,
    order_uuid,
    comment,
    status,
    resolution,
    name,
    description,
    picture_link,
    weight,
    category,
    price,
    customer_uuid,
    is_draft,
    dish_uuid,
    created_at,
    updated_at
)
SELECT
    input.uuid,
    input.order_uuid,
    input.comment,
    input.status,
    input.resolution,
    input.name,
    input.description,
    input.picture_link,
    input.weight,
    input.category,
    input.price,
    input.customer_uuid,
    input.is_draft,
    input.dish_uuid,
    input.created_at,
    input.updated_at
FROM jsonb_to_recordset($1::jsonb) AS input(
   uuid          UUID,
   order_uuid    UUID,
   comment       TEXT,
   status        TEXT,
   resolution    TEXT,
   name          TEXT,
   description   TEXT,
   picture_link  TEXT,
   weight        INT,
   category      TEXT,
   price         DECIMAL,
   customer_uuid UUID,
   is_draft      BOOLEAN,
   dish_uuid     UUID,
   created_at    TIMESTAMPTZ,
   updated_at    TIMESTAMPTZ
)
ON CONFLICT (uuid) DO UPDATE
SET
    order_uuid = EXCLUDED.order_uuid,
    comment = EXCLUDED.comment,
    status = EXCLUDED.status,
    resolution = EXCLUDED.resolution,
    is_draft = EXCLUDED.is_draft
RETURNING uuid
`

// args:
// $1 - JSONB
func (q *Queries) UpsertItems(ctx context.Context, dollar_1 []byte) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, upsertItems, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var uuid uuid.UUID
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
