// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: fetch_orders_by_uuid.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const fetchOrders = `-- name: FetchOrders :many

SELECT jsonb_agg(order_data)
FROM (
    SELECT jsonb_build_object(
        'order', to_jsonb(o)
    ) || jsonb_build_object(
        'items',
        (
            COALESCE((
                SELECT jsonb_agg(to_jsonb(i))
                FROM smart_table_customer.items i
                WHERE i.order_uuid = o.uuid
            ), '[]'::jsonb)
        )
    ) || jsonb_build_object(
        'customers',
        (
            COALESCE((
                SELECT jsonb_agg(to_jsonb(c))
                FROM smart_table_customer.customers c
                WHERE c.uuid = ANY(o.customers_uuid)
            ), '[]'::jsonb)
        )
    ) AS order_data
    FROM smart_table_customer.orders AS o
    WHERE o.uuid = ANY($1::UUID[])
) AS orders
`

// args:
// $1 - UUID[]
func (q *Queries) FetchOrders(ctx context.Context, dollar_1 []uuid.UUID) ([][]byte, error) {
	rows, err := q.db.Query(ctx, fetchOrders, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var jsonb_agg []byte
		if err := rows.Scan(&jsonb_agg); err != nil {
			return nil, err
		}
		items = append(items, jsonb_agg)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
